# معرفی
پرهام عسکرزاده ۹۸۱۷۰۹۳۵ <br>
غزال تقوی ۹۸۱۷۰۷۳۲ <br>
آزمایش شماره ۴



این پروژه یک سیستم ساده برای اعلام وضعیت بسته‌های پستی با استفاده از الگوهای طراحی `Strategy` و `State` پیاده‌سازی شده است.

## الگوی Strategy

### ShippingStrategy

الگوی `Strategy` در اینجا برای مدیریت روش‌های مختلف ارسال بسته‌ها استفاده شده است. دو روش ارسال اصلی به نام‌های `StandardShipping` و `ExpressShipping` پیاده‌سازی شده‌اند. این الگو به ما امکان می‌دهد تا بتوانیم به راحتی روش ارسال بسته را در زمان اجرا تغییر دهیم.

### استفاده از ShippingStrategy

برای استفاده از این الگو، یک شیء از نوع `ShippingStrategy` ایجاد کرده و آن را به `PackageContext` منتقل می‌کنیم. سپس می‌توانیم در زمان اجرا روش ارسال را تغییر دهیم.

```java
ShippingStrategy shippingStrategy = new StandardShipping();
PackageContext packageContext = new PackageContext(shippingStrategy);
```

## الگوی State

### PackageState

الگوی `State` برای مدیریت وضعیت‌های مختلف بسته‌ها به کار گرفته شده است. دو وضعیت اصلی به نام‌های `InTransitState` و `DeliveredState` پیاده‌سازی شده‌اند. این الگو امکان تغییر وضعیت بسته در زمان اجرا را فراهم می‌کند.

### استفاده از PackageState

برای استفاده از این الگو، هر بسته یک شیء از نوع `PackageContext` را دارد که وضعیت فعلی بسته را نگه می‌دارد. می‌توانیم در زمان اجرا وضعیت بسته را به راحتی تغییر دهیم.

```java
PackageContext packageContext = new PackageContext();
PackageState newState = new DeliveredState();
packageContext.setState(newState);
```

## نحوه اجرای برنامه

برنامه به صورت خط فرمان اجرا می‌شود و در ابتدا وزن محصول وارد می‌شود. سپس در یک حلقه تا زمانی که بسته به مقصد نرسیده باشد، روش ارسال و وضعیت بسته وارد می‌شود.

## ایجاد آزمون‌ها

برای اطمینان از صحت عملکرد هر کدام از کلاس‌ها، از رویکرد توسعه مبتنی بر آزمون (TDD) استفاده شده است. فایل‌های تست با نام‌های `ShippingStrategyTest.java` و `PackageContextTest.java` آماده شده‌اند.

## نحوه اجرای تست‌ها

تست‌ها با استفاده از فریمورک JUnit نوشته شده‌اند. برای اجرای تست‌ها، از IDE مورد نظر یا ابزار مدیریت پروژه (مانند Maven) استفاده کنید.

```
mvn test
```


## سوالات مطرح شده

## دسته‌های الگوهای طراحی GoF:

1. **ساختاری (Structural):**
    - **Adapter Pattern:** این الگو به دو رابط متفاوت را به یکدیگر تطبیق می‌دهد.
    - **Composite Pattern:** این الگو اجازه می‌دهد تا اشیاء را به صورت ساختار درختی گروه‌بندی کنیم.

2. **رفتاری (Behavioral):**
    - **Strategy Pattern:** این الگو اجازه می‌دهد یک خانواده از الگوریتم‌ها را تعریف کرده و از هر الگوریتم بتواند به صورت متقاطع استفاده کند.
    - **State Pattern:** این الگو این امکان را فراهم می‌کند که یک شیء تغییرات در وضعیت خود را داشته باشد و رفتار خود را بر اساس وضعیت تغییر دهد.

3. **سازنده (Creational):**
    - **Singleton Pattern:** این الگو اطمینان می‌حکمد که یک کلاس فقط یک نمونه داشته باشد و به همه کلاس‌ها امکان دسترسی به این نمونه را فراهم می‌کند.

## الگوهای استفاده شده در این آزمایش:

- **Strategy Pattern:** برای مدیریت روش‌های مختلف ارسال بسته‌ها.
- **State Pattern:** برای مدیریت وضعیت‌های مختلف بسته‌ها.

## الگوی طراحی برای ایجاد بسته:

- **Singleton Pattern:** از آنجا که در هر لحظه تنها یک بسته داریم و هیچ بسته‌ای دیگر نداریم. این الگو اطمینان می‌دهد که تنها یک نمونه از کلاس بسته ایجاد می‌شود.

### اصول SOLID:

- **Single Responsibility Principle (SRP):** الگوی طراحی Singleton یک مسئولیت وظیفه ایجاد یک نمونه یکتا را دارد.
- **Open/Closed Principle (OCP):** با استفاده از الگوی Singleton، کلاس می‌تواند بسته شود و امکان گسترش داده‌شدن برای اضافه کردن ویژگی‌ها وجود دارد.
- **Dependency Inversion Principle (DIP):** بستگی به نحوه پیاده‌سازی، ممکن است DIP رعایت نشود. اما به طور کلی، Singleton معمولاً از وابستگی‌های بالا به پایین استفاده می‌کند.


